## Recap
What is an OS?
Basic hardware blocks
OS Structure
Diff archs
Operations

# OS provided services

**What are the services provided by OS?**

As a user i expect to have: 
1) User Interface
	- GUI: Graphical User Interface
	- CLI: Command Line Interface
2) File System Manipulation
	- Create/delete/rename/move/ files/directory
	- permissions/search
	- ...
3) Program Execution
	- Load and execute programs
4) Access I/O devices
	- Manage drivers
5) Communication
	- Inter process communication
6) Protection + Security
7) Accounting
	- keep track of users/process usage
8) Resource Allocation
	- How to allocate resources to processes.
	- If proc wants memory how does it get it?
		- Use service provided by OS
9) Error Detection
	- Logging

## How to use these services?
**System calls:** Interface provided for devs to use OS services.

Ex. Want to write copy file service.
	Need file names: ask user.
		1) Write to display
		2) read Input
	Same with output file
		open Input file
		create output file
			Errors can happen
	Loop reading/writing (sys calls)
	Close files (sys call) and exit (sys call)

## Typically an API is used rather than the native sys call.
**API:** App programming interface
	Provides a set of functions (with parameters, and return values) that are available to the programmer.
Ex. 
	Win32
	JAVA
	POSIX => Portable OS Interface

System calls are invoked from within the API.

Why use?
	1) Simple: Wraps around a sys call to make it simpler to use.
	2) Portability: A program would run on any system that supports the API

Caller of API needs to know parameters to pass and return values, **Nothing Internal**


## Types of system calls
1) Process Control (exec, fork, exit, pause, resume,...)
2) File management
	- move
	- copy
	- read
	- write
	- create
	- delete
	- remove dir
	- open
	- close
3) I/O Device Manipulation
	- read
	- write
	- request(if device can only be used by on process at a time)
	- release
4) information maintenance
	- get/set time/day...
5) communication
	- read
	- write
	- send
	- recieve
	- create connection
	- socket
	- ...
6) memory management
	- memmap
	- memunmap
	- memlock
	- memunlock
7) Protection
	- set/get permissions(chmod)

## How to structure the OS
Main challenge
	Large
	complex
	Want it to be extensible

Approaches:
### **Simple**
Start small but grew over time beyond the original scope

*Get diagram from profs notes*

**Monolithic**

### Layered 
Modularize system design
	Break system into a bunch of layers

*Get diagram from profs notes*

Every interface has access to another layer

Advantage:
	1) Hides complexity
		- no details needed except the interface
	2) Simpler to construct and debug

Disadvantage:
	1) Less efficient due to crossing multiple layers
		- have to copy data/return values across them
	2) How do you map functionality to a layer?(What layer will have what responsibility?)


### Micro Kernels
Idea: Make kernel very small.
	Take core components needed to run OS and make as small as possible.
	Non essential components are implemented as system and user programs.
Think of as opposite of monolithic

*Get diagram from profs notes*

Kernel provides communication between processes through message passing.

Advantage:
1) Simple kernel, easy to debug
2) Easy to extend(just need to add a service. No compilation into OS needed)

Disadvantage:
1) Lots of overhead from message passing


### Modules
Kernel has a set of core components linked to additional ones which can be loaded either on boot or at runtime
	Ex. DLL on windows: Dynamic Loadable Library